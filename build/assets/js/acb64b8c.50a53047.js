"use strict";(globalThis.webpackChunkai_humanoid_book=globalThis.webpackChunkai_humanoid_book||[]).push([[398],{4295(n,e,r){r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>_,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"isaac-ai-brain/nav2-humanoid","title":"Nav2 for Humanoid Navigation","description":"Introduction to Humanoid Navigation","source":"@site/docs/isaac-ai-brain/nav2-humanoid.md","sourceDirName":"isaac-ai-brain","slug":"/isaac-ai-brain/nav2-humanoid","permalink":"/Ai_Humanoid_Book/docs/isaac-ai-brain/nav2-humanoid","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-ai-brain/nav2-humanoid.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Isaac ROS Accelerated Perception","permalink":"/Ai_Humanoid_Book/docs/isaac-ai-brain/isaac-ros"},"next":{"title":"VLA Integration Home","permalink":"/Ai_Humanoid_Book/docs/vla-integration/"}}');var i=r(4848),t=r(8453);const o={},s="Nav2 for Humanoid Navigation",l={},c=[{value:"Introduction to Humanoid Navigation",id:"introduction-to-humanoid-navigation",level:2},{value:"Nav2 Architecture Overview",id:"nav2-architecture-overview",level:2},{value:"Core Nav2 Components",id:"core-nav2-components",level:3},{value:"Nav2 Parameters for Humanoid Robots",id:"nav2-parameters-for-humanoid-robots",level:3},{value:"Humanoid-Specific Navigation Challenges",id:"humanoid-specific-navigation-challenges",level:2},{value:"Bipedal Locomotion Constraints",id:"bipedal-locomotion-constraints",level:3},{value:"Footstep Planning",id:"footstep-planning",level:3},{value:"Nav2 Configuration for Humanoid Robots",id:"nav2-configuration-for-humanoid-robots",level:2},{value:"Costmap Configuration",id:"costmap-configuration",level:3},{value:"Controller Configuration",id:"controller-configuration",level:3},{value:"Humanoid Navigation Strategies",id:"humanoid-navigation-strategies",level:2},{value:"Gait Pattern Integration",id:"gait-pattern-integration",level:3},{value:"Balance and Stability",id:"balance-and-stability",level:3},{value:"Isaac Sim Integration for Navigation Testing",id:"isaac-sim-integration-for-navigation-testing",level:2},{value:"Simulation Environment Setup",id:"simulation-environment-setup",level:3},{value:"Isaac ROS Nav2 Bridge",id:"isaac-ros-nav2-bridge",level:3},{value:"Best Practices for Humanoid Navigation",id:"best-practices-for-humanoid-navigation",level:2},{value:"Path Planning Optimization",id:"path-planning-optimization",level:3},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Nav2 Configuration for Humanoid Robot",id:"exercise-1-nav2-configuration-for-humanoid-robot",level:3},{value:"Exercise 2: Footstep Planning Integration",id:"exercise-2-footstep-planning-integration",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"nav2-for-humanoid-navigation",children:"Nav2 for Humanoid Navigation"})}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-humanoid-navigation",children:"Introduction to Humanoid Navigation"}),"\n",(0,i.jsx)(e.p,{children:"Navigation for humanoid robots presents unique challenges compared to wheeled or tracked robots. Humanoid robots must navigate with bipedal locomotion, which introduces considerations for balance, gait patterns, and dynamic stability. Nav2 (Navigation 2) provides the foundation for navigation, but requires adaptation for humanoid-specific movement patterns."}),"\n",(0,i.jsx)(e.p,{children:"Humanoid navigation involves:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Bipedal gait planning"}),": Coordinated leg movement for stable walking"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Balance maintenance"}),": Center of mass control during movement"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Footstep planning"}),": Placement of feet for stable locomotion"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic obstacle avoidance"}),": Navigation around moving obstacles with safety margins"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"nav2-architecture-overview",children:"Nav2 Architecture Overview"}),"\n",(0,i.jsx)(e.h3,{id:"core-nav2-components",children:"Core Nav2 Components"}),"\n",(0,i.jsx)(e.p,{children:"Nav2 consists of several key components that work together:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Global Planner"}),": Path planning from start to goal"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Local Planner"}),": Real-time obstacle avoidance and path following"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Controller"}),": Low-level command generation for robot actuators"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Recovery Behaviors"}),": Actions when navigation fails"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Costmap Management"}),": Representation of environment obstacles and costs"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"nav2-parameters-for-humanoid-robots",children:"Nav2 Parameters for Humanoid Robots"}),"\n",(0,i.jsx)(e.p,{children:"Configuring Nav2 for humanoid-specific navigation requires specialized parameters:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'# Nav2 configuration for humanoid navigation\r\nbt_navigator:\r\n  ros__parameters:\r\n    # Behavior tree configuration\r\n    use_sim_time: true\r\n    global_frame: map\r\n    robot_base_frame: base_link\r\n    odom_topic: /odom\r\n    bt_loop_duration: 10\r\n    default_server_timeout: 20\r\n\r\n    # Plugins\r\n    action_server_result_timeout: 900.0\r\n    navigate_to_pose_goal_checker: "goal_checker"\r\n\r\n    # Server names\r\n    navigate_through_poses_server_name: "navigate_through_poses"\r\n    navigate_to_pose_server_name: "navigate_to_pose"\r\n\r\n    # Behavior tree\r\n    default_nav_to_pose_bt_xml: "navigate_to_pose_w_replanning_and_recovery.xml"\r\n    default_nav_through_poses_bt_xml: "navigate_through_poses_w_replanning_and_recovery.xml"\r\n\r\n    # Plugins\r\n    plugin_lib_names:\r\n      - nav2_compute_path_to_pose_action_bt_node\r\n      - nav2_compute_path_through_poses_action_bt_node\r\n      - nav2_smooth_path_action_bt_node\r\n      - nav2_follow_path_action_bt_node\r\n      - nav2_spin_action_bt_node\r\n      - nav2_wait_action_bt_node\r\n      - nav2_assisted_teleop_action_bt_node\r\n      - nav2_back_up_action_bt_node\r\n      - nav2_drive_on_heading_bt_node\r\n      - nav2_clear_costmap_service_bt_node\r\n      - nav2_is_stuck_condition_bt_node\r\n      - nav2_goal_reached_condition_bt_node\r\n      - nav2_goal_updated_condition_bt_node\r\n      - nav2_initial_pose_received_condition_bt_node\r\n      - nav2_reinitialize_global_localization_service_bt_node\r\n      - nav2_rate_controller_bt_node\r\n      - nav2_distance_controller_bt_node\r\n      - nav2_speed_controller_bt_node\r\n      - nav2_truncate_path_action_bt_node\r\n      - nav2_truncate_path_local_action_bt_node\r\n      - nav2_goal_updater_node_bt_node\r\n      - nav2_recovery_node_bt_node\r\n      - nav2_pipeline_sequence_bt_node\r\n      - nav2_round_robin_node_bt_node\r\n      - nav2_transform_available_condition_bt_node\r\n      - nav2_time_expired_condition_bt_node\r\n      - nav2_path_expiring_timer_condition\r\n      - nav2_distance_traveled_condition_bt_node\r\n      - nav2_single_trigger_bt_node\r\n      - nav2_is_battery_low_condition_bt_node\r\n      - nav2_navigate_through_poses_action_bt_node\r\n      - nav2_navigate_to_pose_action_bt_node\r\n      - nav2_remove_passed_goals_action_bt_node\r\n      - nav2_planner_selector_bt_node\r\n      - nav2_controller_selector_bt_node\r\n      - nav2_goal_checker_selector_bt_node\r\n      - nav2_controller_cancel_bt_node\r\n      - nav2_path_longer_on_approach_bt_node\r\n      - nav2_wait_cancel_bt_node\n'})}),"\n",(0,i.jsx)(e.h2,{id:"humanoid-specific-navigation-challenges",children:"Humanoid-Specific Navigation Challenges"}),"\n",(0,i.jsx)(e.h3,{id:"bipedal-locomotion-constraints",children:"Bipedal Locomotion Constraints"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid robots have unique constraints that affect navigation:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Stability requirements"}),": Must maintain balance during movement"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Step size limitations"}),": Finite step length and height"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Turning radius"}),": Limited by leg configuration"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Terrain adaptability"}),": Must handle uneven surfaces"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"footstep-planning",children:"Footstep Planning"}),"\n",(0,i.jsx)(e.p,{children:"Footstep planning is critical for humanoid navigation:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# Example footstep planning algorithm\r\nimport numpy as np\r\nfrom scipy.spatial import distance\r\n\r\nclass FootstepPlanner:\r\n    def __init__(self, step_length_max=0.3, step_width_max=0.2):\r\n        self.step_length_max = step_length_max  # Maximum step length\r\n        self.step_width_max = step_width_max    # Maximum step width\r\n        self.step_height_max = 0.1              # Maximum step height\r\n\r\n    def plan_footsteps(self, path, robot_pose):\r\n        """\r\n        Plan footsteps along a given path considering humanoid constraints\r\n        """\r\n        footsteps = []\r\n        current_pose = robot_pose\r\n\r\n        for i in range(len(path) - 1):\r\n            target_pose = path[i + 1]\r\n\r\n            # Calculate required step\r\n            step_vector = np.array([\r\n                target_pose[0] - current_pose[0],\r\n                target_pose[1] - current_pose[1]\r\n            ])\r\n\r\n            # Check if step is within humanoid constraints\r\n            if self.is_step_feasible(step_vector):\r\n                # Generate footstep\r\n                footstep = self.generate_footstep(current_pose, target_pose)\r\n                footsteps.append(footstep)\r\n                current_pose = target_pose\r\n            else:\r\n                # Break down into smaller steps\r\n                sub_steps = self.divide_step(step_vector)\r\n                for sub_step in sub_steps:\r\n                    footstep = self.generate_footstep(current_pose, sub_step)\r\n                    footsteps.append(footstep)\r\n                    current_pose = sub_step\r\n\r\n        return footsteps\r\n\r\n    def is_step_feasible(self, step_vector):\r\n        """\r\n        Check if a step is within humanoid robot constraints\r\n        """\r\n        step_length = np.linalg.norm(step_vector[:2])\r\n        step_height = abs(step_vector[2]) if len(step_vector) > 2 else 0\r\n\r\n        return (step_length <= self.step_length_max and\r\n                step_height <= self.step_height_max)\r\n\r\n    def generate_footstep(self, current_pose, target_pose):\r\n        """\r\n        Generate a footstep with proper orientation and placement\r\n        """\r\n        # Calculate foot placement considering gait pattern\r\n        footstep = {\r\n            \'position\': target_pose,\r\n            \'orientation\': self.calculate_orientation(current_pose, target_pose),\r\n            \'step_type\': \'normal\',  # or \'adjustment\', \'recovery\'\r\n            \'timing\': self.calculate_timing(current_pose, target_pose)\r\n        }\r\n        return footstep\r\n\r\n    def calculate_orientation(self, current_pose, target_pose):\r\n        """\r\n        Calculate proper foot orientation for stable placement\r\n        """\r\n        # Calculate orientation based on movement direction\r\n        dx = target_pose[0] - current_pose[0]\r\n        dy = target_pose[1] - current_pose[1]\r\n        yaw = np.arctan2(dy, dx)\r\n        return yaw\n'})}),"\n",(0,i.jsx)(e.h2,{id:"nav2-configuration-for-humanoid-robots",children:"Nav2 Configuration for Humanoid Robots"}),"\n",(0,i.jsx)(e.h3,{id:"costmap-configuration",children:"Costmap Configuration"}),"\n",(0,i.jsx)(e.p,{children:"Configuring costmaps for humanoid navigation requires special consideration:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'# Costmap configuration for humanoid navigation\r\nglobal_costmap:\r\n  global_costmap:\r\n    ros__parameters:\r\n      update_frequency: 1.0\r\n      publish_frequency: 1.0\r\n      global_frame: map\r\n      robot_base_frame: base_link\r\n      use_sim_time: true\r\n      rolling_window: false\r\n\r\n      # Humanoid-specific inflation\r\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\r\n\r\n      # Static layer\r\n      static_layer:\r\n        plugin: "nav2_costmap_2d::StaticLayer"\r\n        map_topic: "map"\r\n        transform_tolerance: 0.35\r\n        max_publish_frequency: 1.0\r\n\r\n      # Obstacle layer\r\n      obstacle_layer:\r\n        plugin: "nav2_costmap_2d::ObstacleLayer"\r\n        enabled: True\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 3.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 2.5\r\n          obstacle_min_range: 0.0\r\n\r\n      # Inflation layer\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0  # Increased for humanoid safety\r\n        inflation_radius: 0.6     # Larger safety margin for bipedal movement\r\n        inflate_unknown: false\r\n\r\nlocal_costmap:\r\n  local_costmap:\r\n    ros__parameters:\r\n      update_frequency: 5.0\r\n      publish_frequency: 2.0\r\n      global_frame: odom\r\n      robot_base_frame: base_link\r\n      use_sim_time: true\r\n      rolling_window: true\r\n      width: 4\r\n      height: 4\r\n      resolution: 0.05\r\n\r\n      # Plugins for local costmap\r\n      plugins: ["obstacle_layer", "voxel_layer", "inflation_layer"]\r\n\r\n      # Voxel layer for 3D obstacles\r\n      voxel_layer:\r\n        plugin: "nav2_costmap_2d::VoxelLayer"\r\n        enabled: True\r\n        publish_voxel_map: true\r\n        origin_z: 0.0\r\n        z_resolution: 0.2\r\n        z_voxels: 8\r\n        max_obstacle_height: 2.0\r\n        mark_threshold: 0\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 3.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 2.5\r\n          obstacle_min_range: 0.0\r\n\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 5.0  # Higher for local safety\r\n        inflation_radius: 0.5     # Humanoid safety margin\n'})}),"\n",(0,i.jsx)(e.h3,{id:"controller-configuration",children:"Controller Configuration"}),"\n",(0,i.jsx)(e.p,{children:"Configuring controllers for humanoid-specific movement:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:'# Controller configuration for humanoid navigation\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: true\r\n    controller_frequency: 20.0\r\n    min_x_velocity_threshold: 0.001\r\n    min_y_velocity_threshold: 0.5\r\n    min_theta_velocity_threshold: 0.001\r\n    failure_tolerance: 0.3\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugin: "goal_checker"\r\n    controller_plugins: ["FollowPath"]\r\n\r\n    # Humanoid-specific controller\r\n    FollowPath:\r\n      plugin: "nav2_mppi::SimpleProgressChecker"\r\n      required_movement_radius: 0.5\r\n      movement_time_allowance: 10.0\r\n\r\nprogress_checker:\r\n  ros__parameters:\r\n    plugin: "nav2_controller::SimpleProgressChecker"\r\n    required_movement_radius: 0.5  # Increased for humanoid step size\r\n    movement_time_allowance: 10.0\r\n\r\ngoal_checker:\r\n  ros__parameters:\r\n    plugin: "nav2_controller::SimpleGoalChecker"\r\n    xy_goal_tolerance: 0.25      # Adjusted for humanoid precision\r\n    yaw_goal_tolerance: 0.25     # Adjusted for humanoid orientation\r\n    stateful: true\n'})}),"\n",(0,i.jsx)(e.h2,{id:"humanoid-navigation-strategies",children:"Humanoid Navigation Strategies"}),"\n",(0,i.jsx)(e.h3,{id:"gait-pattern-integration",children:"Gait Pattern Integration"}),"\n",(0,i.jsx)(e.p,{children:"Integrating gait patterns with navigation:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Static walking"}),": Stable, slow movement with constant support"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic walking"}),": Faster movement with controlled falling"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Stepping stones"}),": Precise foot placement on specific locations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Turning strategies"}),": Coordinated turning with balance maintenance"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"balance-and-stability",children:"Balance and Stability"}),"\n",(0,i.jsx)(e.p,{children:"Maintaining balance during navigation:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# Balance controller for humanoid navigation\r\nclass BalanceController:\r\n    def __init__(self):\r\n        self.com_reference = np.array([0.0, 0.0, 0.8])  # Center of mass reference\r\n        self.zmp_reference = np.array([0.0, 0.0])       # Zero moment point reference\r\n        self.control_gain = 10.0\r\n\r\n    def compute_balance_control(self, current_com, current_zmp):\r\n        """\r\n        Compute balance control adjustments for humanoid navigation\r\n        """\r\n        # Calculate errors\r\n        com_error = self.com_reference - current_com\r\n        zmp_error = self.zmp_reference - current_zmp[:2]\r\n\r\n        # Compute control adjustments\r\n        com_control = self.control_gain * com_error\r\n        zmp_control = self.control_gain * zmp_error\r\n\r\n        # Combine controls with navigation commands\r\n        balance_adjustment = {\r\n            \'com_adjustment\': com_control,\r\n            \'zmp_adjustment\': zmp_control,\r\n            \'foot_placement_adjustment\': self.compute_foot_placement(com_error)\r\n        }\r\n\r\n        return balance_adjustment\r\n\r\n    def compute_foot_placement(self, com_error):\r\n        """\r\n        Adjust foot placement based on center of mass error\r\n        """\r\n        # Calculate required foot placement to correct CoM error\r\n        foot_adjustment = 0.3 * com_error[:2]  # Proportional adjustment\r\n        return foot_adjustment\n'})}),"\n",(0,i.jsx)(e.h2,{id:"isaac-sim-integration-for-navigation-testing",children:"Isaac Sim Integration for Navigation Testing"}),"\n",(0,i.jsx)(e.h3,{id:"simulation-environment-setup",children:"Simulation Environment Setup"}),"\n",(0,i.jsx)(e.p,{children:"Creating navigation test environments in Isaac Sim:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Obstacle courses"}),": Various obstacles for navigation testing"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Terrain variations"}),": Uneven surfaces and steps"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic obstacles"}),": Moving objects for real-time avoidance"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Mapping scenarios"}),": Environments for SLAM testing"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"isaac-ros-nav2-bridge",children:"Isaac ROS Nav2 Bridge"}),"\n",(0,i.jsx)(e.p,{children:"Integrating Isaac Sim with Nav2:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# Isaac Sim to Nav2 bridge example\r\nimport omni\r\nfrom omni.isaac.core import World\r\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\r\nimport rclpy\r\nfrom nav_msgs.msg import OccupancyGrid, Path\r\nfrom geometry_msgs.msg import PoseStamped\r\n\r\nclass IsaacSimNav2Bridge:\r\n    def __init__(self):\r\n        # Initialize Isaac Sim world\r\n        self.world = World(stage_units_in_meters=1.0)\r\n\r\n        # Initialize ROS 2\r\n        rclpy.init()\r\n        self.node = rclpy.create_node(\'isaac_sim_nav2_bridge\')\r\n\r\n        # Publishers and subscribers\r\n        self.map_publisher = self.node.create_publisher(\r\n            OccupancyGrid, \'/map\', 1\r\n        )\r\n        self.path_publisher = self.node.create_publisher(\r\n            Path, \'/plan\', 1\r\n        )\r\n        self.goal_subscriber = self.node.create_subscription(\r\n            PoseStamped, \'/goal_pose\', self.goal_callback, 1\r\n        )\r\n\r\n    def goal_callback(self, goal_msg):\r\n        """\r\n        Handle navigation goals from Nav2\r\n        """\r\n        # Convert ROS goal to Isaac Sim coordinates\r\n        isaac_goal = self.ros_to_isaac_coordinates(goal_msg.pose)\r\n\r\n        # Update Isaac Sim environment\r\n        self.update_navigation_task(isaac_goal)\r\n\r\n        # Execute navigation in simulation\r\n        self.execute_navigation()\r\n\r\n    def update_navigation_task(self, goal):\r\n        """\r\n        Update the navigation task in Isaac Sim\r\n        """\r\n        # Set navigation goal in Isaac Sim\r\n        # Update robot position and orientation\r\n        # Configure environment obstacles\r\n        pass\r\n\r\n    def execute_navigation(self):\r\n        """\r\n        Execute navigation task in Isaac Sim\r\n        """\r\n        # Run simulation steps\r\n        # Collect sensor data\r\n        # Update Nav2 with simulation results\r\n        pass\n'})}),"\n",(0,i.jsx)(e.h2,{id:"best-practices-for-humanoid-navigation",children:"Best Practices for Humanoid Navigation"}),"\n",(0,i.jsx)(e.h3,{id:"path-planning-optimization",children:"Path Planning Optimization"}),"\n",(0,i.jsx)(e.p,{children:"Optimizing paths for humanoid capabilities:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Step feasibility"}),": Ensure path segments are achievable with humanoid step constraints"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Turning radius"}),": Account for limited turning capabilities"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Obstacle clearance"}),": Maintain adequate safety margins for bipedal stability"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Terrain analysis"}),": Consider surface characteristics for foot placement"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,i.jsx)(e.p,{children:"Safety measures for humanoid navigation:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Fall prevention"}),": Maintain stability margins during navigation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Emergency stops"}),": Implement immediate stop capabilities"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Recovery behaviors"}),": Plan for balance recovery when needed"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Human awareness"}),": Maintain safe distances from humans"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsx)(e.h3,{id:"exercise-1-nav2-configuration-for-humanoid-robot",children:"Exercise 1: Nav2 Configuration for Humanoid Robot"}),"\n",(0,i.jsx)(e.p,{children:"Configure Nav2 for a humanoid robot simulation:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Set up costmap parameters appropriate for bipedal movement"}),"\n",(0,i.jsx)(e.li,{children:"Configure controller parameters for humanoid gait patterns"}),"\n",(0,i.jsx)(e.li,{children:"Test navigation in a simple environment"}),"\n",(0,i.jsx)(e.li,{children:"Evaluate path planning and obstacle avoidance performance"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"exercise-2-footstep-planning-integration",children:"Exercise 2: Footstep Planning Integration"}),"\n",(0,i.jsx)(e.p,{children:"Implement footstep planning with Nav2:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Create a footstep planner that works with Nav2 paths"}),"\n",(0,i.jsx)(e.li,{children:"Integrate balance control with navigation commands"}),"\n",(0,i.jsx)(e.li,{children:"Test on various terrain types"}),"\n",(0,i.jsx)(e.li,{children:"Analyze the relationship between path planning and footstep execution"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"Nav2 for humanoid navigation requires specialized configuration and algorithms to handle the unique challenges of bipedal locomotion. By adapting path planning, local navigation, and control systems for humanoid constraints, robots can achieve stable and efficient navigation. The integration with Isaac Sim and Isaac ROS provides a complete development and testing environment for humanoid navigation systems."}),"\n",(0,i.jsx)(e.p,{children:"This completes the Isaac AI Brain module, covering Isaac Sim fundamentals, Isaac ROS accelerated perception, and Nav2 for humanoid navigation as requested in the plan."})]})}function _(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453(n,e,r){r.d(e,{R:()=>o,x:()=>s});var a=r(6540);const i={},t=a.createContext(i);function o(n){const e=a.useContext(t);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),a.createElement(t.Provider,{value:e},n.children)}}}]);