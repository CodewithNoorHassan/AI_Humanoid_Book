"use strict";(globalThis.webpackChunkai_humanoid_book=globalThis.webpackChunkai_humanoid_book||[]).push([[116],{5354(e,i,n){n.r(i),n.d(i,{assets:()=>r,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>c});var o=n(4848),s=n(8453);const l={},t="Physics Simulation with Gazebo",a={id:"digital-twin/gazebo-physics",title:"Physics Simulation with Gazebo",description:"Introduction to Gazebo for Robotics",source:"@site/docs/digital-twin/gazebo-physics.md",sourceDirName:"digital-twin",slug:"/digital-twin/gazebo-physics",permalink:"/Ai_Humanoid_Book/docs/digital-twin/gazebo-physics",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/digital-twin/gazebo-physics.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introduction to Digital Twins in Robotics",permalink:"/Ai_Humanoid_Book/docs/digital-twin/intro"},next:{title:"Virtual Sensor Modeling",permalink:"/Ai_Humanoid_Book/docs/digital-twin/virtual-sensors"}},r={},c=[{value:"Introduction to Gazebo for Robotics",id:"introduction-to-gazebo-for-robotics",level:2},{value:"Setting up Gazebo for Digital Twins",id:"setting-up-gazebo-for-digital-twins",level:2},{value:"Installing Gazebo",id:"installing-gazebo",level:3},{value:"Basic Gazebo Concepts",id:"basic-gazebo-concepts",level:3},{value:"Understanding Gazebo Physics Parameters",id:"understanding-gazebo-physics-parameters",level:2},{value:"Gravity Configuration",id:"gravity-configuration",level:3},{value:"Mass and Inertial Properties",id:"mass-and-inertial-properties",level:3},{value:"Friction Parameters",id:"friction-parameters",level:3},{value:"Damping and Restitution",id:"damping-and-restitution",level:3},{value:"Implementing Physics Simulation",id:"implementing-physics-simulation",level:2},{value:"Step-by-Step: Creating Your First Gazebo World",id:"step-by-step-creating-your-first-gazebo-world",level:3},{value:"Step 1: Create a World File",id:"step-1-create-a-world-file",level:4},{value:"Step 2: Launch the World",id:"step-2-launch-the-world",level:4},{value:"Gravity and Environmental Forces",id:"gravity-and-environmental-forces",level:3},{value:"Collision Detection and Response",id:"collision-detection-and-response",level:3},{value:"Collision Geometry Types",id:"collision-geometry-types",level:4},{value:"Configuring Collision Properties",id:"configuring-collision-properties",level:4},{value:"Collision Layers and Filtering",id:"collision-layers-and-filtering",level:4},{value:"Material Properties and Friction",id:"material-properties-and-friction",level:3},{value:"Humanoid Motion Simulation",id:"humanoid-motion-simulation",level:2},{value:"Joint Dynamics",id:"joint-dynamics",level:3},{value:"Joint Types in Gazebo",id:"joint-types-in-gazebo",level:4},{value:"Configuring Joint Properties",id:"configuring-joint-properties",level:4},{value:"Example: Simple Humanoid Leg",id:"example-simple-humanoid-leg",level:4},{value:"Actuator Modeling",id:"actuator-modeling",level:3},{value:"Best Practices for Physics Simulation",id:"best-practices-for-physics-simulation",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Validation Techniques",id:"validation-techniques",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Simple Pendulum Simulation",id:"exercise-1-simple-pendulum-simulation",level:3},{value:"Exercise 2: Collision Response Testing",id:"exercise-2-collision-response-testing",level:3},{value:"Exercise 3: Humanoid Balance Challenge",id:"exercise-3-humanoid-balance-challenge",level:3},{value:"Summary",id:"summary",level:2},{value:"Cross-References",id:"cross-references",level:2},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.h1,{id:"physics-simulation-with-gazebo",children:"Physics Simulation with Gazebo"}),"\n",(0,o.jsx)(i.h2,{id:"introduction-to-gazebo-for-robotics",children:"Introduction to Gazebo for Robotics"}),"\n",(0,o.jsx)(i.p,{children:"Gazebo is a powerful physics simulation environment that provides realistic robot simulation capabilities. It's widely used in the robotics community for testing algorithms, validating behaviors, and developing robotic systems without the need for physical hardware."}),"\n",(0,o.jsx)(i.h2,{id:"setting-up-gazebo-for-digital-twins",children:"Setting up Gazebo for Digital Twins"}),"\n",(0,o.jsx)(i.h3,{id:"installing-gazebo",children:"Installing Gazebo"}),"\n",(0,o.jsx)(i.p,{children:"Gazebo can be installed as part of the ROS 2 ecosystem or as a standalone application. For robotics applications, installing through ROS 2 is recommended as it includes integration packages."}),"\n",(0,o.jsx)(i.p,{children:"On Ubuntu with ROS 2 Humble:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",children:"sudo apt update\nsudo apt install ros-humble-gazebo-*\n"})}),"\n",(0,o.jsx)(i.h3,{id:"basic-gazebo-concepts",children:"Basic Gazebo Concepts"}),"\n",(0,o.jsx)(i.p,{children:"Gazebo operates using several core concepts:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Worlds"}),": Define the environment including lighting, physics parameters, and objects"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Models"}),": 3D representations of objects with physical properties"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Plugins"}),": Extend Gazebo's functionality (sensors, controllers, etc.)"]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"understanding-gazebo-physics-parameters",children:"Understanding Gazebo Physics Parameters"}),"\n",(0,o.jsx)(i.h3,{id:"gravity-configuration",children:"Gravity Configuration"}),"\n",(0,o.jsx)(i.p,{children:"Gravity is defined in the world file and affects all objects in the simulation:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:"<world>\n  <gravity>0 0 -9.8</gravity>\n  \x3c!-- x, y, z components of gravitational acceleration --\x3e\n</world>\n"})}),"\n",(0,o.jsx)(i.p,{children:"For different environments:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Earth-like: ",(0,o.jsx)(i.code,{children:"<gravity>0 0 -9.8</gravity>"})]}),"\n",(0,o.jsxs)(i.li,{children:["Moon-like: ",(0,o.jsx)(i.code,{children:"<gravity>0 0 -1.62</gravity>"})]}),"\n",(0,o.jsxs)(i.li,{children:["Zero gravity: ",(0,o.jsx)(i.code,{children:"<gravity>0 0 0</gravity>"})]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"mass-and-inertial-properties",children:"Mass and Inertial Properties"}),"\n",(0,o.jsx)(i.p,{children:"Each model component requires mass and inertial properties:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<link name="link_name">\n  <inertial>\n    <mass>1.0</mass>  \x3c!-- Mass in kilograms --\x3e\n    <inertia>\n      <ixx>0.01</ixx>  \x3c!-- Moments of inertia --\x3e\n      <iyy>0.01</iyy>\n      <izz>0.01</izz>\n      <ixy>0</ixy>     \x3c!-- Products of inertia --\x3e\n      <ixz>0</ixz>\n      <iyz>0</iyz>\n    </inertia>\n  </inertial>\n</link>\n'})}),"\n",(0,o.jsx)(i.h3,{id:"friction-parameters",children:"Friction Parameters"}),"\n",(0,o.jsx)(i.p,{children:"Friction affects how objects interact when in contact:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<link name="link_name">\n  <collision name="collision">\n    <surface>\n      <friction>\n        <ode>\n          <mu>1.0</mu>      \x3c!-- Static friction coefficient --\x3e\n          <mu2>1.0</mu2>    \x3c!-- Secondary friction coefficient --\x3e\n          <slip1>0</slip1>  \x3c!-- Slip in primary direction --\x3e\n          <slip2>0</slip2>  \x3c!-- Slip in secondary direction --\x3e\n        </ode>\n      </friction>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,o.jsx)(i.h3,{id:"damping-and-restitution",children:"Damping and Restitution"}),"\n",(0,o.jsx)(i.p,{children:"Damping and restitution control energy loss and bounciness:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<link name="link_name">\n  <inertial>\n    <damping>\n      <linear>0.01</linear>   \x3c!-- Linear velocity damping --\x3e\n      <angular>0.01</angular> \x3c!-- Angular velocity damping --\x3e\n    </damping>\n  </inertial>\n  <collision name="collision">\n    <surface>\n      <bounce>\n        <restitution_coefficient>0.2</restitution_coefficient> \x3c!-- Bounciness --\x3e\n        <threshold>100000.0</threshold> \x3c!-- Velocity threshold for bounce --\x3e\n      </bounce>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,o.jsx)(i.h2,{id:"implementing-physics-simulation",children:"Implementing Physics Simulation"}),"\n",(0,o.jsx)(i.h3,{id:"step-by-step-creating-your-first-gazebo-world",children:"Step-by-Step: Creating Your First Gazebo World"}),"\n",(0,o.jsx)(i.p,{children:"Let's create a basic Gazebo world with a simple robot model:"}),"\n",(0,o.jsx)(i.h4,{id:"step-1-create-a-world-file",children:"Step 1: Create a World File"}),"\n",(0,o.jsxs)(i.p,{children:["Create a file named ",(0,o.jsx)(i.code,{children:"simple_world.world"}),":"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="simple_world">\n    \x3c!-- Set gravity --\x3e\n    <gravity>0 0 -9.8</gravity>\n\n    \x3c!-- Include a default physics profile --\x3e\n    <physics name="default_physics" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    \x3c!-- Add a ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Add lighting --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Define a simple box model --\x3e\n    <model name="simple_box">\n      <pose>0 0 1 0 0 0</pose>\n      <link name="link">\n        <inertial>\n          <mass>1.0</mass>\n          <inertia>\n            <ixx>0.1</ixx>\n            <iyy>0.1</iyy>\n            <izz>0.1</izz>\n          </inertia>\n        </inertial>\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>0.5 0.5 0.5</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>0.5 0.5 0.5</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.2 0.1 1</ambient>\n            <diffuse>0.8 0.2 0.1 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(i.h4,{id:"step-2-launch-the-world",children:"Step 2: Launch the World"}),"\n",(0,o.jsx)(i.p,{children:"Save the file and launch it with:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",children:"gazebo simple_world.world\n"})}),"\n",(0,o.jsx)(i.h3,{id:"gravity-and-environmental-forces",children:"Gravity and Environmental Forces"}),"\n",(0,o.jsx)(i.p,{children:"In any realistic digital twin, gravity is fundamental to creating believable robot behaviors. We'll explore how to configure gravitational parameters in Gazebo to match real-world conditions."}),"\n",(0,o.jsx)(i.h3,{id:"collision-detection-and-response",children:"Collision Detection and Response"}),"\n",(0,o.jsx)(i.p,{children:"Proper collision detection ensures that robots interact realistically with their environment. We'll cover different collision models and how to configure them."}),"\n",(0,o.jsx)(i.h4,{id:"collision-geometry-types",children:"Collision Geometry Types"}),"\n",(0,o.jsx)(i.p,{children:"Gazebo supports several collision geometry types:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Box"}),": Rectangular prism, useful for simple objects"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Sphere"}),": Perfect spheres for round objects"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Cylinder"}),": Cylindrical shapes"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Mesh"}),": Complex shapes using 3D mesh files"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Plane"}),": Infinite flat surfaces (useful for ground planes)"]}),"\n"]}),"\n",(0,o.jsx)(i.h4,{id:"configuring-collision-properties",children:"Configuring Collision Properties"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<collision name="collision_name">\n  <geometry>\n    <box>\n      <size>1.0 1.0 1.0</size>\n    </box>\n  </geometry>\n  <surface>\n    <contact>\n      <ode>\n        <max_vel>100</max_vel>           \x3c!-- Maximum contact penetration velocity --\x3e\n        <min_depth>0.001</min_depth>     \x3c!-- Penetration depth for contact stabilization --\x3e\n      </ode>\n    </contact>\n    <friction>\n      <ode>\n        <mu>1.0</mu>                    \x3c!-- Primary friction coefficient --\x3e\n        <mu2>1.0</mu2>                  \x3c!-- Secondary friction coefficient --\x3e\n        <fdir1>1 0 0</fdir1>            \x3c!-- Friction direction --\x3e\n      </ode>\n    </friction>\n  </surface>\n</collision>\n'})}),"\n",(0,o.jsx)(i.h4,{id:"collision-layers-and-filtering",children:"Collision Layers and Filtering"}),"\n",(0,o.jsx)(i.p,{children:"For complex environments, you can use collision layers to control which objects interact:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<collision name="collision_name">\n  <surface>\n    <contact>\n      <collide_without_contact>0</collide_without_contact>  \x3c!-- Enable/disable collision --\x3e\n    </contact>\n  </surface>\n</collision>\n'})}),"\n",(0,o.jsx)(i.h3,{id:"material-properties-and-friction",children:"Material Properties and Friction"}),"\n",(0,o.jsx)(i.p,{children:"The physical properties of surfaces and robot components affect how they interact. We'll examine how to configure material properties for realistic interactions."}),"\n",(0,o.jsx)(i.h2,{id:"humanoid-motion-simulation",children:"Humanoid Motion Simulation"}),"\n",(0,o.jsx)(i.h3,{id:"joint-dynamics",children:"Joint Dynamics"}),"\n",(0,o.jsx)(i.p,{children:"Humanoid robots have complex joint systems that require careful simulation. We'll explore how to model these dynamics accurately."}),"\n",(0,o.jsx)(i.h4,{id:"joint-types-in-gazebo",children:"Joint Types in Gazebo"}),"\n",(0,o.jsx)(i.p,{children:"Gazebo supports several joint types essential for humanoid robots:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Revolute"}),": Rotational joints with a single degree of freedom (e.g., elbow, knee)"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Prismatic"}),": Linear joints moving along one axis"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Fixed"}),": Rigid connections between links"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Ball"}),": Ball-and-socket joints allowing free rotation"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Universal"}),": Two degrees of freedom, like a double pendulum"]}),"\n"]}),"\n",(0,o.jsx)(i.h4,{id:"configuring-joint-properties",children:"Configuring Joint Properties"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<joint name="knee_joint" type="revolute">\n  <parent>thigh_link</parent>\n  <child>calf_link</child>\n  <axis>\n    <xyz>0 1 0</xyz>                \x3c!-- Rotation axis --\x3e\n    <limit>\n      <lower>-1.57</lower>          \x3c!-- Lower limit in radians --\x3e\n      <upper>1.57</upper>           \x3c!-- Upper limit in radians --\x3e\n      <effort>100.0</effort>        \x3c!-- Maximum effort (N-m) --\x3e\n      <velocity>1.0</velocity>      \x3c!-- Maximum velocity (rad/s) --\x3e\n    </limit>\n    <dynamics>\n      <damping>1.0</damping>         \x3c!-- Damping coefficient --\x3e\n      <friction>0.1</friction>      \x3c!-- Static friction --\x3e\n    </dynamics>\n  </axis>\n</joint>\n'})}),"\n",(0,o.jsx)(i.h4,{id:"example-simple-humanoid-leg",children:"Example: Simple Humanoid Leg"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'\x3c!-- Thigh link --\x3e\n<link name="thigh">\n  <inertial>\n    <mass>5.0</mass>\n    <inertia>\n      <ixx>0.1</ixx>\n      <iyy>0.1</iyy>\n      <izz>0.1</izz>\n    </inertia>\n  </inertial>\n  <visual name="visual">\n    <geometry>\n      <cylinder>\n        <radius>0.08</radius>\n        <length>0.4</length>\n      </cylinder>\n    </geometry>\n  </visual>\n  <collision name="collision">\n    <geometry>\n      <cylinder>\n        <radius>0.08</radius>\n        <length>0.4</length>\n      </cylinder>\n    </geometry>\n  </collision>\n</link>\n\n\x3c!-- Calf link --\x3e\n<link name="calf">\n  <inertial>\n    <mass>3.0</mass>\n    <inertia>\n      <ixx>0.05</ixx>\n      <iyy>0.05</iyy>\n      <izz>0.05</izz>\n    </inertia>\n  </inertial>\n  <visual name="visual">\n    <geometry>\n      <cylinder>\n        <radius>0.07</radius>\n        <length>0.4</length>\n      </cylinder>\n    </geometry>\n  </visual>\n  <collision name="collision">\n    <geometry>\n      <cylinder>\n        <radius>0.07</radius>\n        <length>0.4</length>\n      </cylinder>\n    </geometry>\n  </collision>\n</link>\n\n\x3c!-- Knee joint --\x3e\n<joint name="knee" type="revolute">\n  <parent>thigh</parent>\n  <child>calf</child>\n  <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="-0.5" upper="2.0" effort="200" velocity="1.0"/>\n</joint>\n'})}),"\n",(0,o.jsx)(i.h3,{id:"actuator-modeling",children:"Actuator Modeling"}),"\n",(0,o.jsx)(i.p,{children:"Realistic actuator behavior is crucial for believable humanoid motion. We'll cover how to simulate actuator limitations and characteristics."}),"\n",(0,o.jsx)(i.h2,{id:"best-practices-for-physics-simulation",children:"Best Practices for Physics Simulation"}),"\n",(0,o.jsx)(i.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(i.p,{children:"Balancing simulation accuracy with computational efficiency is crucial for real-time digital twins."}),"\n",(0,o.jsx)(i.h3,{id:"validation-techniques",children:"Validation Techniques"}),"\n",(0,o.jsx)(i.p,{children:"Ensuring that your simulation accurately reflects real-world physics is essential for effective digital twins."}),"\n",(0,o.jsx)(i.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsx)(i.h3,{id:"exercise-1-simple-pendulum-simulation",children:"Exercise 1: Simple Pendulum Simulation"}),"\n",(0,o.jsx)(i.p,{children:"Create a pendulum model in Gazebo with realistic physics:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Design a simple pendulum with a fixed joint at the top"}),"\n",(0,o.jsx)(i.li,{children:"Configure appropriate mass and inertial properties"}),"\n",(0,o.jsx)(i.li,{children:"Implement gravity and observe the pendulum's motion"}),"\n",(0,o.jsx)(i.li,{children:"Adjust damping parameters to see how they affect motion"}),"\n",(0,o.jsx)(i.li,{children:"Measure the oscillation period and compare to theoretical calculations"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"exercise-2-collision-response-testing",children:"Exercise 2: Collision Response Testing"}),"\n",(0,o.jsx)(i.p,{children:"Design a test environment to explore collision physics:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Create a sloped surface in your world file"}),"\n",(0,o.jsx)(i.li,{children:"Add objects with different friction coefficients (0.1, 0.5, 1.0)"}),"\n",(0,o.jsx)(i.li,{children:"Observe how each object slides down the slope"}),"\n",(0,o.jsx)(i.li,{children:"Document how friction affects motion and final position"}),"\n",(0,o.jsx)(i.li,{children:"Add restitution coefficients and observe bouncing behavior"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"exercise-3-humanoid-balance-challenge",children:"Exercise 3: Humanoid Balance Challenge"}),"\n",(0,o.jsx)(i.p,{children:"Extend the simple leg example to create a basic balancing mechanism:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Build a simple biped model with two legs and a torso"}),"\n",(0,o.jsx)(i.li,{children:"Implement basic joint controllers to maintain balance"}),"\n",(0,o.jsx)(i.li,{children:"Apply external forces to test stability"}),"\n",(0,o.jsx)(i.li,{children:"Adjust center of mass and observe effects on stability"}),"\n",(0,o.jsx)(i.li,{children:"Document the relationship between base of support and balance"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(i.p,{children:"Physics simulation forms the foundation of any realistic digital twin. By carefully configuring gravitational forces, collision properties, and joint dynamics, we can create virtual environments that accurately reflect real-world physics. Proper physics simulation is essential for validating robot behaviors before deployment to physical hardware."}),"\n",(0,o.jsx)(i.p,{children:"This chapter has provided a comprehensive overview of Gazebo physics simulation, from basic setup to advanced configuration of joint dynamics and humanoid motion. You've learned how to configure realistic physics parameters including gravity, mass, friction, and damping, as well as how to create complex humanoid joint systems. The exercises have given you hands-on experience with pendulum simulation, collision response testing, and humanoid balance challenges."}),"\n",(0,o.jsx)(i.p,{children:"In the next chapter, we'll explore virtual sensor modeling, building on the physics foundation to create realistic sensor simulations that complement the physical behaviors."}),"\n",(0,o.jsx)(i.h2,{id:"cross-references",children:"Cross-References"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Previous Chapter"}),": ",(0,o.jsx)(i.a,{href:"/Ai_Humanoid_Book/docs/intro",children:"Introduction to Digital Twins"})," - Understanding the fundamental concepts of digital twin systems"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Next Chapter"}),": ",(0,o.jsx)(i.a,{href:"/Ai_Humanoid_Book/docs/digital-twin/virtual-sensors",children:"Virtual Sensor Modeling"})," - Building on physics simulation to create realistic sensor models"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Related Topic"}),": ",(0,o.jsx)(i.a,{href:"/Ai_Humanoid_Book/docs/digital-twin/unity-interaction",children:"Unity-based Human-Robot Interaction"})," - Visualizing physics-based behaviors in high-fidelity environments"]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"hands-on-exercise",children:"Hands-on Exercise"}),"\n",(0,o.jsx)(i.p,{children:"Create a simple humanoid robot model in Gazebo and implement basic physics behaviors including gravity response and collision detection."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,i,n){n.d(i,{R:()=>t,x:()=>a});var o=n(6540);const s={},l=o.createContext(s);function t(e){const i=o.useContext(l);return o.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),o.createElement(l.Provider,{value:i},e.children)}}}]);